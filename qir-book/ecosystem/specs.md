# Data Types in `qir-spec`
QIR defines a wide set of LLVM-based representations for both classical and quantum data types. They can be used to build compiled quantum programs from compatible source code. The representations are intended to be versatile enough to support the various quantum development platforms, and flexible enough to be converted into executable code for any quantum computer. The intermediate representation by QIR specification allows for code transformers and analyzers to operate at the IR level before the final target-specific code generation.
# Qubit (`%Qubit`)
If a value of a varaible is known at compile time, meaning its value is determined during the compilation phase of the program, the corresponding memory allocation for that value is statically allocated. This means that the memory is allocated and determined before the program is executed. On the other hand, if a value is not known until runtime, meaning its value is determined during the execution of the program, the memory allocation for that value is dynamic. Static qubits have target-specific identifiers known at compile time and dynamic qubits are managed with quantum runtime.
# Measurement (`%Result`)
In terms of measurement result, they are many quantum computation paradigms and corresponding vendors’ architectures. The result value can determine the next quantum or classical operations. Hybrid computation control flow requires the value result to dictate the following operations or termination. Currently, they are many quantum computing paradigms and corresponding algorithms that venders take advantage of. QIR’s measurement values are presented by opaque LLVM structure type. Further, LLVM functions provide tools compare and presents null, zero, one and negative values of measurement results. Deallocated result values are assigned a 0 value.

# Fixed-Size Types and Unlimited-Precision Integers

These values assign a certain size to the memory for integers, doubles, bools, Pauli and range with start, stop and non-zero step values.
The `%BigInt` type is provided to handle integer values that exceed the range of standard integer types, thereby avoiding overflow errors. Simple integer type in LLVM have predefined sizes and can represent a limited range of integer values. When performing arithmetic operations on integers that exceed this range, overflow can occur, resulting in unexpected behavior or loss of precision. To address this limitation, a big integer type is used. It allows for arbitrary-precision arithmetic, meaning it can handle integers of any size.
# Strings (`%String`)
Pointers are used to represent strings as opaque types. The classical runtime provides utility functions for strings, including creating and getting data from a string, updating the reference count, concatenating, and checking for equality. Moreover, there are functions for converting other types to strings such as integers, doubles, booleans, results, Paulis, qubits, ranges and big integers. In all cases, a runtime failure should occur if a pointer parameter is null.
 The length of the string depends on the input value, so the string must be dynamically allocated on the heap rather than being allocated by the function caller. Meaning that the function responsible for converting the input value to a string must dynamically allocate a memory block on the heap to store the resulting string, and then return a pointer to the corresponding memory block. The caller of the function must then ensure that the memory block is eventually freed to prevent memory leaks. By ensuring that the returned string is always dynamically allocated on the heap, the function can handle inputs of varying length and return a string of the correct length without causing buffer over and under flows or memory corruption.
# Tuples (`%Tuple`)
In LLVM, tuple data, which includes values of user-defined types, is represented using the corresponding LLVM structure type. To represent tuple data in QIR, the corresponding LLVM structure type is used, with each tuple element represented by a specific data structure. When using the __quantum__rt__callable_invoke runtime function, tuples are passed as pointers to opaque LLVM structures. In some languages, tuples are immutable values and so the `__quantum__rt__tuple_copy` function is used to create a copy of the tuple before modification. The `__quantum__rt__tuple_update_alias_count` function is used to keep track of how many handles to the tuple exist in the source code. To manage tuples, the classical runtime provides utility functions for creating, copying, and updating the reference and alias counts. These functions should fail and cause a runtime error if the %Tuple* parameter is null.
# Arrays (`%Array`)

In QIR, arrays are represented and manipulated using a pointer to an opaque LLVM structure called %Array. The specific representation of array data, i.e., what the pointer points to, is determined by the runtime. All array operations, including element access, need to be performed using the corresponding runtime functions. However, when creating an array, the size of each element in bytes must be known.

Since LLVM does not support type-parameterized functions, runtime library routines that provide access to array elements return byte pointers. The calling code needs to bitcast these pointers to the appropriate type before using them.

Many quantum developing frameworks have immutable arrays and operators that allow the creation of modified copies of existing arrays. In QIR, this is achieved by creating a new copy of the original array and modifying it in place. To enable this, the compatable compiler should ensure that the alias count for arrays accurately reflects their usage in the source language. The runtime function for copying the array can then omit the copy when the alias count is 0.

In addition to creating modified copies of arrays, QIR supports two other methods for constructing new arrays with similar optimizations: array slicing and array projections.

Array slicing involves specifying a dimension to slice on and a `%Range` to define the slice. The resulting array has the same number of dimensions as the original array but includes only the elements from the sliced dimension that correspond to the resolved `%Range` indices. Array slices can be created using the` __quantum__rt__array_slice_1d` or `__quantum__rt__array_slice` functions.

Array projection involves specifying a dimension to project along and an index value to project to. The resulting array has one fewer dimension than the original array, with the projected dimension fixed at the specified index value. Array projections can be created using the `__quantum__rt__array_project` function.

Attempting to access an index or dimension outside the bounds of an array will result in a runtime failure. This applies to slicing, projection operations, and element access. When validating indices for slicing, only indices that are part of the resolved range should be considered.

The classical runtime provides utility functions to support arrays, including functions for creating arrays, copying arrays, concatenating arrays, obtaining array sizes, accessing array elements, and updating reference and alias counts. There are additional functions for multidimensional arrays if supported.